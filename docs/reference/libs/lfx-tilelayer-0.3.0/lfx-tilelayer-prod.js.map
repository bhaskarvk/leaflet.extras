{"version":3,"file":"lfx-tilelayer-prod.js","mappings":"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","sources":["webpack://leaflet.extras/./node_modules/leaflet.tilelayer.pouchdbcached/L.TileLayer.PouchDBCached.js"],"sourcesContent":["\n\nL.TileLayer.addInitHook(function() {\n\n\tif (!this.options.useCache) {\n\t\tthis._db     = null;\n\t\tthis._canvas = null;\n\t\treturn;\n\t}\n\n\tif (this.options.dbOptions) {\n\t\tthis._db = new PouchDB('offline-tiles', this.options.dbOptions);\n\t} else {\n\t\tthis._db = new PouchDB('offline-tiles');\n\t}\n\tthis._canvas = document.createElement('canvas');\n\n\tif (!(this._canvas.getContext && this._canvas.getContext('2d'))) {\n\t\t// HTML5 canvas is needed to pack the tiles as base64 data. If\n\t\t//   the browser doesn't support canvas, the code will forcefully\n\t\t//   skip caching the tiles.\n\t\tthis._canvas = null;\n\t}\n});\n\n// 🍂namespace TileLayer\n// 🍂section PouchDB tile caching options\n// 🍂option useCache: Boolean = false\n// Whether to use a PouchDB cache on this tile layer, or not\nL.TileLayer.prototype.options.useCache     = false;\n\n// 🍂option saveToCache: Boolean = true\n// When caching is enabled, whether to save new tiles to the cache or not\nL.TileLayer.prototype.options.saveToCache  = true;\n\n// 🍂option useOnlyCache: Boolean = false\n// When caching is enabled, whether to request new tiles from the network or not\nL.TileLayer.prototype.options.useOnlyCache = false;\n\n// 🍂option useCache: String = 'image/png'\n// The image format to be used when saving the tile images in the cache\nL.TileLayer.prototype.options.cacheFormat = 'image/png';\n\n// 🍂option cacheMaxAge: Number = 24*3600*1000\n// Maximum age of the cache, in milliseconds\nL.TileLayer.prototype.options.cacheMaxAge  = 24*3600*1000;\n\n\nL.TileLayer.include({\n\n\t// Overwrites L.TileLayer.prototype.createTile\n\tcreateTile: function(coords, done) {\n\t\tvar tile = document.createElement('img');\n\n\t\ttile.onerror = L.bind(this._tileOnError, this, done, tile);\n\n\t\tif (this.options.crossOrigin) {\n\t\t\ttile.crossOrigin = '';\n\t\t}\n\n\t\t/*\n\t\t Alt tag is *set to empty string to keep screen readers from reading URL and for compliance reasons\n\t\t http://www.w3.org/TR/WCAG20-TECHS/H67\n\t\t */\n\t\ttile.alt = '';\n\n\t\tvar tileUrl = this.getTileUrl(coords);\n\n\t\tif (this.options.useCache && this._canvas) {\n\t\t\tthis._db.get(tileUrl, {revs_info: true}, this._onCacheLookup(tile, tileUrl, done));\n\t\t} else {\n\t\t\t// Fall back to standard behaviour\n\t\t\ttile.onload = L.bind(this._tileOnLoad, this, done, tile);\n\t\t}\n\n\t\ttile.src = tileUrl;\n\t\treturn tile;\n\t},\n\n\t// Returns a callback (closure over tile/key/originalSrc) to be run when the DB\n\t//   backend is finished with a fetch operation.\n\t_onCacheLookup: function(tile, tileUrl, done) {\n\t\treturn function(err, data) {\n\t\t\tif (data) {\n\t\t\t\tthis.fire('tilecachehit', {\n\t\t\t\t\ttile: tile,\n\t\t\t\t\turl: tileUrl\n\t\t\t\t});\n\t\t\t\tif (Date.now() > data.timestamp + this.options.cacheMaxAge && !this.options.useOnlyCache) {\n\t\t\t\t\t// Tile is too old, try to refresh it\n\t\t\t\t\t//console.log('Tile is too old: ', tileUrl);\n\n\t\t\t\t\tif (this.options.saveToCache) {\n\t\t\t\t\t\ttile.onload = L.bind(this._saveTile, this, tile, tileUrl, data._revs_info[0].rev, done);\n\t\t\t\t\t}\n\t\t\t\t\ttile.crossOrigin = 'Anonymous';\n\t\t\t\t\ttile.src = tileUrl;\n\t\t\t\t\ttile.onerror = function(ev) {\n\t\t\t\t\t\t// If the tile is too old but couldn't be fetched from the network,\n\t\t\t\t\t\t//   serve the one still in cache.\n\t\t\t\t\t\tthis.src = data.dataUrl;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Serve tile from cached data\n\t\t\t\t\t//console.log('Tile is cached: ', tileUrl);\n\t\t\t\t\ttile.onload = L.bind(this._tileOnLoad, this, done, tile);\n\t\t\t\t\ttile.src = data.dataUrl;    // data.dataUrl is already a base64-encoded PNG image.\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.fire('tilecachemiss', {\n\t\t\t\t\ttile: tile,\n\t\t\t\t\turl: tileUrl\n\t\t\t\t});\n\t\t\t\tif (this.options.useOnlyCache) {\n\t\t\t\t\t// Offline, not cached\n// \t\t\t\t\tconsole.log('Tile not in cache', tileUrl);\n\t\t\t\t\ttile.onload = L.Util.falseFn;\n\t\t\t\t\ttile.src = L.Util.emptyImageUrl;\n\t\t\t\t} else {\n\t\t\t\t\t//Online, not cached, request the tile normally\n// \t\t\t\t\tconsole.log('Requesting tile normally', tileUrl);\n\t\t\t\t\tif (this.options.saveToCache) {\n\t\t\t\t\t\ttile.onload = L.bind(this._saveTile, this, tile, tileUrl, null, done);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttile.onload = L.bind(this._tileOnLoad, this, done, tile);\n\t\t\t\t\t}\n\t\t\t\t\ttile.crossOrigin = 'Anonymous';\n\t\t\t\t\ttile.src = tileUrl;\n\t\t\t\t}\n\t\t\t}\n\t\t}.bind(this);\n\t},\n\n\t// Returns an event handler (closure over DB key), which runs\n\t//   when the tile (which is an <img>) is ready.\n\t// The handler will delete the document from pouchDB if an existing revision is passed.\n\t//   This will keep just the latest valid copy of the image in the cache.\n\t_saveTile: function(tile, tileUrl, existingRevision, done) {\n\t\tif (this._canvas === null) return;\n\t\tthis._canvas.width  = tile.naturalWidth  || tile.width;\n\t\tthis._canvas.height = tile.naturalHeight || tile.height;\n\n\t\tvar context = this._canvas.getContext('2d');\n\t\tcontext.drawImage(tile, 0, 0);\n\n\t\tvar dataUrl;\n\t\ttry {\n\t\t\tdataUrl = this._canvas.toDataURL(this.options.cacheFormat);\n\t\t} catch(err) {\n\t\t\tthis.fire('tilecacheerror', { tile: tile, error: err });\n\t\t\treturn done();\n\t\t}\n\n\t\tvar doc = {_id: tileUrl, dataUrl: dataUrl, timestamp: Date.now()};\n\t    if (existingRevision) {\n\t      this._db.get(tileUrl).then(function(doc) {\n\t          return this._db.put({\n\t              _id: doc._id,\n\t              _rev: doc._rev,\n\t              dataUrl: dataUrl,\n\t              timestamp: Date.now()\n\t          });\n\t      }.bind(this)).then(function(response) {\n\t        //console.log('_saveTile update: ', response);\n\t      });\n\t    } else {\n\t      this._db.put(doc).then( function(doc) {\n\t        //console.log('_saveTile insert: ', doc);\n\t      });\n\t    }\n\n\t    if (done) {\n\t      done();\n\t    }\n\t},\n\n\t// 🍂section PouchDB tile caching options\n\t// 🍂method seed(bbox: LatLngBounds, minZoom: Number, maxZoom: Number): this\n\t// Starts seeding the cache given a bounding box and the minimum/maximum zoom levels\n\t// Use with care! This can spawn thousands of requests and flood tileservers!\n\tseed: function(bbox, minZoom, maxZoom) {\n\t\tif (!this.options.useCache) return;\n\t\tif (minZoom > maxZoom) return;\n\t\tif (!this._map) return;\n\n\t\tvar queue = [];\n\n\t\tfor (var z = minZoom; z<=maxZoom; z++) {\n\n\t\t\tvar northEastPoint = this._map.project(bbox.getNorthEast(),z);\n\t\t\tvar southWestPoint = this._map.project(bbox.getSouthWest(),z);\n\n\t\t\t// Calculate tile indexes as per L.TileLayer._update and\n\t\t\t//   L.TileLayer._addTilesFromCenterOut\n\t\t\tvar tileSize = this.getTileSize();\n\t\t\tvar tileBounds = L.bounds(\n\t\t\t\tL.point(Math.floor(northEastPoint.x / tileSize.x), Math.floor(northEastPoint.y / tileSize.y)),\n\t\t\t\tL.point(Math.floor(southWestPoint.x / tileSize.x), Math.floor(southWestPoint.y / tileSize.y)));\n\n\t\t\tfor (var j = tileBounds.min.y; j <= tileBounds.max.y; j++) {\n\t\t\t\tfor (var i = tileBounds.min.x; i <= tileBounds.max.x; i++) {\n\t\t\t\t\tpoint = new L.Point(i, j);\n\t\t\t\t\tpoint.z = z;\n\t\t\t\t\tqueue.push(this._getTileUrl(point));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar seedData = {\n\t\t\tbbox: bbox,\n\t\t\tminZoom: minZoom,\n\t\t\tmaxZoom: maxZoom,\n\t\t\tqueueLength: queue.length\n\t\t}\n\t\tthis.fire('seedstart', seedData);\n\t\tvar tile = this._createTile();\n\t\ttile._layer = this;\n\t\tthis._seedOneTile(tile, queue, seedData);\n\t\treturn this;\n\t},\n\n\t_createTile: function () {\n\t\treturn new Image();\n\t},\n\n\t// Modified L.TileLayer.getTileUrl, this will use the zoom given by the parameter coords\n\t//  instead of the maps current zoomlevel.\n\t_getTileUrl: function (coords) {\n\t\tvar zoom = coords.z;\n\t\tif (this.options.zoomReverse) {\n\t\t\tzoom = this.options.maxZoom - zoom;\n\t\t}\n\t\tzoom += this.options.zoomOffset;\n\t\treturn L.Util.template(this._url, L.extend({\n\t\t\tr: this.options.detectRetina && L.Browser.retina && this.options.maxZoom > 0 ? '@2x' : '',\n\t\t\ts: this._getSubdomain(coords),\n\t\t\tx: coords.x,\n\t\t\ty: this.options.tms ? this._globalTileRange.max.y - coords.y : coords.y,\n\t\t\tz: this.options.maxNativeZoom ? Math.min(zoom, this.options.maxNativeZoom) : zoom\n\t\t}, this.options));\n\t},\n\n\t// Uses a defined tile to eat through one item in the queue and\n\t//   asynchronously recursively call itself when the tile has\n\t//   finished loading.\n\t_seedOneTile: function(tile, remaining, seedData) {\n\t\tif (!remaining.length) {\n\t\t\tthis.fire('seedend', seedData);\n\t\t\treturn;\n\t\t}\n\t\tthis.fire('seedprogress', {\n\t\t\tbbox:    seedData.bbox,\n\t\t\tminZoom: seedData.minZoom,\n\t\t\tmaxZoom: seedData.maxZoom,\n\t\t\tqueueLength: seedData.queueLength,\n\t\t\tremainingLength: remaining.length\n\t\t});\n\n\t\tvar url = remaining.pop();\n\n\t\tthis._db.get(url, function(err, data) {\n\t\t\tif (!data) {\n\t\t\t\ttile.onload = function(e) {\n\t\t\t\t\tthis._saveTile(tile, url, null);\n\t\t\t\t\tthis._seedOneTile(tile, remaining, seedData);\n\t\t\t\t}.bind(this);\n\t\t\t\ttile.onerror = function(e) {\n\t\t\t\t\t// Could not load tile, let's continue anyways.\n\t\t\t\t\tthis._seedOneTile(tile, remaining, seedData);\n\t\t\t\t}.bind(this);\n\t\t\t\ttile.crossOrigin = 'Anonymous';\n\t\t\t\ttile.src = url;\n\t\t\t} else {\n\t\t\t\tthis._seedOneTile(tile, remaining, seedData);\n\t\t\t}\n\t\t}.bind(this));\n\t}\n\n});\n"],"names":["L","TileLayer","addInitHook","this","options","useCache","_db","_canvas","dbOptions","PouchDB","document","createElement","getContext","prototype","saveToCache","useOnlyCache","cacheFormat","cacheMaxAge","include","createTile","coords","done","tile","onerror","bind","_tileOnError","crossOrigin","alt","tileUrl","getTileUrl","get","revs_info","_onCacheLookup","onload","_tileOnLoad","src","err","data","fire","url","Date","now","timestamp","_saveTile","_revs_info","rev","ev","dataUrl","Util","falseFn","emptyImageUrl","existingRevision","width","naturalWidth","height","naturalHeight","drawImage","toDataURL","error","doc","_id","then","put","_rev","response","seed","bbox","minZoom","maxZoom","_map","queue","z","northEastPoint","project","getNorthEast","southWestPoint","getSouthWest","tileSize","getTileSize","tileBounds","bounds","point","Math","floor","x","y","j","min","max","i","Point","push","_getTileUrl","seedData","queueLength","length","_createTile","_layer","_seedOneTile","Image","zoom","zoomReverse","zoomOffset","template","_url","extend","r","detectRetina","Browser","retina","s","_getSubdomain","tms","_globalTileRange","maxNativeZoom","remaining","remainingLength","pop","e"],"sourceRoot":""}