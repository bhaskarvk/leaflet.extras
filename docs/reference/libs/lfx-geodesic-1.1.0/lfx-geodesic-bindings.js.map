<<<<<<< HEAD:inst/htmlwidgets/build/lfx-geodesic/lfx-geodesic-bindings.js.map
{"version":3,"file":"lfx-geodesic-bindings.js","mappings":";;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,qBAAqB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,iBAAiB;AAC5D;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,iBAAiB;AACxF;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,SAAS;AACT,2BAA2B,eAAe;AAC1C;AACA;AACA;AACA;AACA","sources":["webpack://leaflet.extras/./inst/htmlwidgets/bindings/lfx-geodesic-bindings.js"],"sourcesContent":["/* global $, LeafletWidget, L, HTMLWidgets */\r\nLeafletWidget.methods.addGeodesicPolylines  = function(\r\n  polygons, layerId, group, options, icon, popup, popupOptions,\r\n  label, labelOptions, highlightOptions, markerOptions, pts) {\r\n  if(polygons.length > 0) {\r\n\r\n    const map = this;\r\n\r\n    console.log(\"START\"); console.log(polygons)\r\n\r\n    // Show Statistics in InfoControl\r\n    if (options.showStats) {\r\n      // Info control\r\n      var info = L.control();\r\n      info.onAdd = function(map) {\r\n          this._div = L.DomUtil.create('div', 'info');\r\n          return this._div;\r\n      };\r\n      info.addTo(map);\r\n\r\n      // Define a function to update the info control based on passed statistics\r\n      function updateInfo(stats, statsFunction) {\r\n        var infoHTML = \"\";\r\n        if (typeof options.statsFunction === \"function\") {\r\n          // If additionalInput is a function, use it to generate content exclusively\r\n          infoHTML = options.statsFunction(stats);\r\n        } else {\r\n          // Default content generation logic\r\n          const totalDistance = stats.totalDistance ? (stats.totalDistance > 10000 ? (stats.totalDistance / 1000).toFixed(0) + ' km' : stats.totalDistance.toFixed(0) + ' m') : 'invalid';\r\n          infoHTML = '<h4>Statistics</h4>' +\r\n            '<b>Total Distance</b><br/>' + totalDistance +\r\n            '<br/><br/><b>Points</b><br/>' + stats.points +\r\n            '<br/><br/><b>Vertices</b><br/>' + stats.vertices;\r\n        }\r\n        // Update the innerHTML of the info div with the constructed info HTML or leave it empty\r\n        info._div.innerHTML = infoHTML;\r\n      }\r\n    }\r\n    // Show Statistics in InfoControl\r\n    var info = L.control();\r\n    info.onAdd = function (map) {\r\n        this._div = L.DomUtil.create('div', 'info'); // create a div with a class \"info\"\r\n        return this._div;\r\n    };\r\n    info.addTo(map);\r\n\r\n    // method that we will use to update the control based on feature properties passed\r\n    info.update = function (stats) {\r\n        const totalDistance = (stats.totalDistance ? (stats.totalDistance > 10000) ? (stats.totalDistance / 1000).toFixed(0) + ' km' : (stats.totalDistance).toFixed(0) + ' m' : 'invalid')\r\n        this._div.innerHTML = '<h4>Statistics</h4><b>totalDistance</b><br/>' + totalDistance +\r\n            '<br/><br/><b>Points</b><br/>' + stats.points +\r\n            '<br/><br/><b>Vertices</b><br/>' + stats.vertices;\r\n    };\r\n\r\n    // Add Lines using addGenericLayers\r\n    debugger;\r\n    const geogesic_coords = polygons.map(line =>\r\n        line[0].flatMap(obj =>\r\n            obj.lat.map((lat, i) => ({lat, lng: obj.lng[i]}))\r\n        )\r\n    );\r\n    const Geodesic = L.geodesic(geogesic_coords, options);\r\n    info.update(Geodesic.statistics);\r\n    map.layerManager.addLayer(Geodesic, \"shape\", null, group, null, null);\r\n\r\n\r\n    var markers = [];\r\n    function updateGeodesic() {\r\n        let currentMultiline = [];\r\n        for (let subMarker of markers) {\r\n            let currentLine = [];\r\n            for (let point of subMarker) {\r\n                currentLine.push(point.getLatLng());\r\n            }\r\n            currentMultiline.push(currentLine);\r\n        }\r\n        Geodesic.setLatLngs(currentMultiline);\r\n        info.update(Geodesic.statistics);\r\n    }\r\n\r\n    for (let line of geogesic_coords) {\r\n        var subMarker = [];\r\n        for (let place of line) {\r\n            var marker = L.marker(place, { draggable: true }).addTo(map);\r\n            //map.layerManager.addLayer(marker, \"markers\", null, group, null, null);\r\n            map.on('layeradd', function(e) {\r\n              if(e.layer === Geodesic) {\r\n                map.layerManager.addLayer(marker, \"marker\", \"fake_layerid\", group, null, null);\r\n              }\r\n            });\r\n            map.on('layerremove', function(e) {\r\n              if(e.layer === Geodesic) {\r\n                map.layerManager.removeLayer(\"marker\", \"fake_layerid\")\r\n              }\r\n            });\r\n            marker.on('drag', (e) => {\r\n              updateGeodesic();\r\n            });\r\n            subMarker.push(marker);\r\n        }\r\n        markers.push(subMarker);\r\n    }\r\n\r\n\r\n\r\n\r\n    /*\r\n    LeafletWidget.methods.addGenericLayers(this, 'shape', df,\r\n      function(df, i) {\r\n        var shapes = df.get(i, 'shapes');\r\n        shapes = shapes.map(shape => HTMLWidgets.dataframeToD3(shape[0]));\r\n        console.log(\"what are the shapes for LINES\"); console.log(shapes)\r\n        const geodesic = L.geodesic(shapes, df.get(i));\r\n\r\n        return geodesic;\r\n      });\r\n      */\r\n\r\n\r\n\r\n/*\r\n\r\n    var info = L.control();\r\n    info.onAdd = function (map) {\r\n        this._div = L.DomUtil.create('div', 'info'); // create a div with a class \"info\"\r\n        return this._div;\r\n    };\r\n    info.addTo(map);\r\n\r\n    // method that we will use to update the control based on feature properties passed\r\n    info.update = function (stats) {\r\n        const totalDistance = (stats.totalDistance ? (stats.totalDistance>10000)?(stats.totalDistance/1000).toFixed(0)+' km':(stats.totalDistance).toFixed(0)+' m' : 'invalid')\r\n        this._div.innerHTML = '<h4>Statistics</h4><b>totalDistance</b><br/>' + totalDistance +\r\n            '<br/><br/><b>Points</b><br/>' + stats.points +\r\n            '<br/><br/><b>Vertices</b><br/>' + stats.vertices;\r\n    };\r\n\r\n    // Make DataFrame for Markers\r\n    var df_marker = new LeafletWidget.DataFrame()\r\n      .col('lat', pts.lat)\r\n      .col('lng', pts.lng)\r\n      .col('layerId', layerId)\r\n      .col('group', group)\r\n      .col('popup', popup)\r\n      .col('popupOptions', popupOptions)\r\n      .col('label', label)\r\n      .col('labelOptions', labelOptions)\r\n      .col('highlightOptions', highlightOptions)\r\n      .cbind(options);\r\n\r\n\r\n    // Add Markers using addGenericLayers\r\n    LeafletWidget.methods.addGenericMarkers(this, df_marker, group, null, null,\r\n      function(df, i) {\r\n        let options = df.get(i);\r\n        if (icon) options.icon = getIcon(i);\r\n        var marker = L.marker([df.get(i, \"lat\"), df.get(i, \"lng\")],  { draggable: true });\r\n        marker.on('drag', (e) => {\r\n            let loc = [];\r\n            markers.forEach( (item) => {\r\n                loc.push(item.getLatLng());\r\n            })\r\n            geodesic.setLatLngs(loc);\r\n            info.update(geodesic.statistics);\r\n        });\r\n        return marker;\r\n      });\r\n\r\n      */\r\n\r\n  }\r\n};\r\n\r\nLeafletWidget.methods.addLatLng = function(latlng) {\r\n  console.log(\"addLatLng\"); console.log(addLatLng)\r\n  // Check if the geodesic object exists\r\n  if (this.geodesic) {\r\n    // Add the new latlng point to the geodesic object\r\n    this.geodesic.addLatLng(latlng);\r\n  } else {\r\n    console.error('Geodesic object is not initialized.');\r\n  }\r\n};\r\n\r\nLeafletWidget.methods.addGreatCircles  = function(\r\n  lat, lng, radius, layerId, group, options, icon, popup, popupOptions,\r\n  label, labelOptions, highlightOptions, markerOptions) {\r\n  if(!($.isEmptyObject(lat) || $.isEmptyObject(lng)) ||\r\n      ($.isNumeric(lat) && $.isNumeric(lng))) {\r\n\r\n    const map = this;\r\n\r\n    // Icon (Copy form Leaflet)\r\n    let icondf;\r\n    let getIcon;\r\n    if (icon) {\r\n      // Unpack icons\r\n      icon.iconUrl         = unpackStrings(icon.iconUrl);\r\n      icon.iconRetinaUrl   = unpackStrings(icon.iconRetinaUrl);\r\n      icon.shadowUrl       = unpackStrings(icon.shadowUrl);\r\n      icon.shadowRetinaUrl = unpackStrings(icon.shadowRetinaUrl);\r\n\r\n      // This cbinds the icon URLs and any other icon options; they're all\r\n      // present on the icon object.\r\n      icondf = new LeafletWidget.DataFrame().cbind(icon);\r\n\r\n      // Constructs an icon from a specified row of the icon dataframe.\r\n      getIcon = function(i) {\r\n        let opts = icondf.get(i);\r\n        if (!opts.iconUrl) {\r\n          return new L.Icon.Default();\r\n        }\r\n\r\n        // Composite options (like points or sizes) are passed from R with each\r\n        // individual component as its own option. We need to combine them now\r\n        // into their composite form.\r\n        if (opts.iconWidth) {\r\n          opts.iconSize = [opts.iconWidth, opts.iconHeight];\r\n        }\r\n        if (opts.shadowWidth) {\r\n          opts.shadowSize = [opts.shadowWidth, opts.shadowHeight];\r\n        }\r\n        if (opts.iconAnchorX) {\r\n          opts.iconAnchor = [opts.iconAnchorX, opts.iconAnchorY];\r\n        }\r\n        if (opts.shadowAnchorX) {\r\n          opts.shadowAnchor = [opts.shadowAnchorX, opts.shadowAnchorY];\r\n        }\r\n        if (opts.popupAnchorX) {\r\n          opts.popupAnchor = [opts.popupAnchorX, opts.popupAnchorY];\r\n        }\r\n\r\n        return new L.Icon(opts);\r\n      };\r\n    }\r\n    if (icon) icondf.effectiveLength = lat.length;\r\n\r\n    // Make DataFrame\r\n    let df = new LeafletWidget.DataFrame()\r\n      .col(\"lat\", lat)\r\n      .col(\"lng\", lng)\r\n      .col(\"radius\", radius)\r\n      .col(\"layerId\", layerId)\r\n      .col(\"group\", group)\r\n      .col(\"popup\", popup)\r\n      .col(\"popupOptions\", popupOptions)\r\n      .col(\"label\", label)\r\n      .col(\"labelOptions\", labelOptions)\r\n      .col(\"highlightOptions\", highlightOptions)\r\n      .col(\"markerOptions\", markerOptions)\r\n      .cbind(options)\r\n\r\n    // Show Statistics in InfoControl\r\n    if (options.showStats) {\r\n      // Info control\r\n      var info = L.control();\r\n      info.onAdd = function(map) {\r\n          this._div = L.DomUtil.create('div', 'info');\r\n          return this._div;\r\n      };\r\n      info.addTo(map);\r\n\r\n      // Define a function to update the info control based on passed statistics\r\n      function updateInfo(stats, statsFunction) {\r\n        var infoHTML = \"\";\r\n        if (typeof options.statsFunction === \"function\") {\r\n          // If additionalInput is a function, use it to generate content exclusively\r\n          infoHTML = options.statsFunction(stats);\r\n        } else {\r\n          // Default content generation logic\r\n          const totalDistance = stats.totalDistance ? (stats.totalDistance > 10000 ? (stats.totalDistance / 1000).toFixed(0) + ' km' : stats.totalDistance.toFixed(0) + ' m') : 'invalid';\r\n          infoHTML = '<h4>Statistics</h4>' +\r\n            '<b>Total Distance</b><br/>' + totalDistance +\r\n            '<br/><br/><b>Points</b><br/>' + stats.points +\r\n            '<br/><br/><b>Vertices</b><br/>' + stats.vertices;\r\n        }\r\n        // Update the innerHTML of the info div with the constructed info HTML or leave it empty\r\n        info._div.innerHTML = infoHTML;\r\n      }\r\n    }\r\n\r\n    // Add Layer using addGenericLayers\r\n    LeafletWidget.methods.addGenericLayers(this, 'shape', df,\r\n      function(df, i) {\r\n        var options = df.get(i);\r\n\r\n        // Create LatLong Centers\r\n        const latlong = new L.LatLng(df.get(i, \"lat\"), df.get(i, \"lng\"))\r\n\r\n        // Create Geodesic Circle\r\n        const Geodesic = new L.GeodesicCircle(latlong, options)\r\n\r\n        // Create a marker for each location\r\n        if (options.showCenter) {\r\n          markerOptions = markerOptions ? markerOptions : {};\r\n          if (options.showCenter && icon) markerOptions.icon = getIcon(i);\r\n          const marker = L.marker(latlong, markerOptions)\r\n\r\n          if (label !== null) {\r\n            if (labelOptions !== null) {\r\n              marker.bindTooltip(df.get(i, \"label\"), labelOptions)\r\n            } else {\r\n              marker.bindTooltip(df.get(i, \"label\"))\r\n            }\r\n          }\r\n          if (popup !== null) {\r\n            if (popupOptions  !== null) {\r\n              marker.bindPopup(df.get(i, \"popup\"), popupOptions)\r\n            } else {\r\n              marker.bindPopup(df.get(i, \"popup\"))\r\n            }\r\n          }\r\n          map.on('layeradd', function(e) {\r\n            if(e.layer === Geodesic) {\r\n              map.layerManager.addLayer(marker, \"marker\", df.get(i, \"layerId\"), df.get(i, \"group\"), null, null);\r\n            }\r\n          });\r\n          map.on('layerremove', function(e) {\r\n            if(e.layer === Geodesic) {\r\n              map.layerManager.removeLayer(\"marker\", df.get(i, \"layerId\"))\r\n            }\r\n          });\r\n\r\n          // Event listener for Center / Circles\r\n          marker.on('drag', (e) => {\r\n            Geodesic.setLatLng(e.latlng);\r\n            handleEvent(e, \"_geodesic_stats\", options, df, i, Geodesic.statistics, updateInfo);\r\n          });\r\n          marker.on('click', (e) => {\r\n            handleEvent(e, \"_geodesic_click\", options, df, i, Geodesic.statistics, updateInfo);\r\n          });\r\n        }\r\n\r\n        Geodesic.on('click', (e) => {\r\n          handleEvent(e, \"_geodesic_click\", options, df, i, Geodesic.statistics, updateInfo);\r\n        });\r\n        Geodesic.on('mouseover', (e) => {\r\n          handleEvent(e, \"_geodesic_mouseover\", options, df, i, Geodesic.statistics, updateInfo);\r\n        });\r\n\r\n        return Geodesic;\r\n    });\r\n  }\r\n};\r\n\r\n\r\n// from https://github.com/rstudio/leaflet/blob/dc772e780317481e25335449b957c5f50082bcfd/javascript/src/methods.js#L221\r\nfunction unpackStrings(iconset) {\r\n  if (!iconset) {\r\n    return iconset;\r\n  }\r\n  if (typeof(iconset.index) === \"undefined\") {\r\n    return iconset;\r\n  }\r\n\r\n  iconset.data = asArray(iconset.data);\r\n  iconset.index = asArray(iconset.index);\r\n\r\n  return $.map(iconset.index, function(e, i) {\r\n    return iconset.data[e];\r\n  });\r\n}\r\nfunction handleEvent(e, eventName, options, df, i, statistics, updateInfo) {\r\n  if (options.showStats) {\r\n      updateInfo(statistics);\r\n  }\r\n  var group = df.get(i, \"group\");\r\n  // Pass Events to Shiny\r\n  if (HTMLWidgets.shinyMode) {\r\n      let latLng = e.target.getLatLng ? e.target.getLatLng() : e.latlng;\r\n      if (latLng) {\r\n          let latLngVal = L.latLng(latLng);\r\n          latLng = { lat: latLngVal.lat, lng: latLngVal.lng };\r\n      }\r\n      let eventInfo = $.extend({\r\n          id: df.get(i, \"layerId\"),\r\n          \".nonce\": Math.random()\r\n        },\r\n        group !== null ? { group: group } : null,\r\n        latLng,\r\n        statistics);\r\n      Shiny.onInputChange(map.id + eventName, eventInfo);\r\n  }\r\n}\r\n"],"names":[],"sourceRoot":""}
=======
{"version":3,"file":"lfx-geodesic-bindings.js","mappings":";;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C,0BAA0B,sBAAsB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA","sources":["webpack://leaflet.extras/./inst/htmlwidgets/bindings/lfx-geodesic-bindings.js"],"sourcesContent":["/* global $, LeafletWidget, L, HTMLWidgets */\r\nLeafletWidget.methods.addGeodesicPolylines  = function(\r\n  polygons, layerId, group, options, popup, popupOptions,\r\n  label, labelOptions, highlightOptions) {\r\n  if(polygons.length > 0) {\r\n    var df = new LeafletWidget.DataFrame()\r\n      .col('shapes', polygons)\r\n      .col('layerId', layerId)\r\n      .col('group', group)\r\n      .col('popup', popup)\r\n      .col('popupOptions', popupOptions)\r\n      .col('label', label)\r\n      .col('labelOptions', labelOptions)\r\n      .col('highlightOptions', highlightOptions)\r\n      .cbind(options);\r\n\r\n    LeafletWidget.methods.addGenericLayers(this, 'shape', df,\r\n      function(df, i) {\r\n        var shapes = df.get(i, 'shapes');\r\n        var ret_shapes = [];\r\n        for (var j = 0; j < shapes.length; j++) {\r\n          for (var k = 0; k < shapes[j].length; k++) {\r\n            ret_shapes.push(\r\n              HTMLWidgets.dataframeToD3(shapes[j][k])\r\n            );\r\n          }\r\n        }\r\n        return L.geodesic(ret_shapes, df.get(i));\r\n      });\r\n  }\r\n};\r\n\r\n\r\nLeafletWidget.methods.addGreatCircles  = function(\r\n  lat, lng, radius, layerId, group, options, popup, popupOptions,\r\n  label, labelOptions, highlightOptions) {\r\n  if(!($.isEmptyObject(lat) || $.isEmptyObject(lng)) ||\r\n      ($.isNumeric(lat) && $.isNumeric(lng))) {\r\n    var df = new LeafletWidget.DataFrame()\r\n      .col('lat', lat)\r\n      .col('lng', lng)\r\n      .col('radius', radius)\r\n      .col('layerId', layerId)\r\n      .col('group', group)\r\n      .col('popup', popup)\r\n      .col('popupOptions', popupOptions)\r\n      .col('label', label)\r\n      .col('labelOptions', labelOptions)\r\n      .col('highlightOptions', highlightOptions)\r\n      .cbind(options);\r\n\r\n    var map = this;\r\n\r\n    LeafletWidget.methods.addGenericLayers(this, 'shape', df,\r\n      function(df, i) {\r\n        var options = df.get(i);\r\n        var Geodesic = L.geodesic([], options);\r\n        var center = L.marker([df.get(i, 'lat'), df.get(i, 'lng')]);\r\n\r\n        map.on('layeradd', function(e) {\r\n          if(e.layer === Geodesic) {\r\n            center.addTo(map);\r\n          }\r\n        });\r\n\r\n        map.on('layerremove', function(e) {\r\n          if(e.layer === Geodesic) {\r\n            map.removeLayer(center);\r\n          }\r\n        });\r\n\r\n        Geodesic.createCircle([df.get(i, 'lat'), df.get(i, 'lng')], df.get(i, 'radius'));\r\n        return Geodesic;\r\n      });\r\n  }\r\n};\r\n"],"names":[],"sourceRoot":""}
>>>>>>> develop:docs/reference/libs/lfx-geodesic-1.1.0/lfx-geodesic-bindings.js.map
