{"version":3,"file":"lfx-omnivore-prod.js","mappings":"2BAAU,EAAQ,KACA,EAAQ,GACV,EAAQ,IACT,EAAQ,KACR,EAAQ,KACP,EAAQ,I,UCuFWA,EAAOC,QA5F1C,SAAkBC,EAAKC,EAAUC,GAC7B,IAAIC,GAAO,EAEX,QAAqC,IAA1BC,OAAOC,eACd,OAAOJ,EAASK,MAAM,0BAG1B,QAAoB,IAATJ,EAAsB,CAC7B,IAAIK,EAAIP,EAAIQ,MAAM,yBAClBN,EAAOK,GAAMA,EAAE,KAAOE,SAASC,SAAW,KAAOD,SAASE,UACjDF,SAASG,KAAO,IAAMH,SAASG,KAAO,GACnD,CAEA,IAAIC,EAAI,IAAIT,OAAOC,eAMnB,GAAIH,KAAU,oBAAqBW,GAAI,CAEnCA,EAAI,IAAIT,OAAOU,eAKf,IAAIC,EAAWd,EACfA,EAAW,WACP,GAAIE,EACAY,EAASC,MAAMC,KAAMC,eAClB,CACH,IAAIC,EAAOF,KAAMG,EAAOF,UACxBG,YAAW,WACPN,EAASC,MAAMG,EAAMC,EACzB,GAAG,EACP,CACJ,CACJ,CAEA,SAASE,IAxBT,IAAsBC,OA2BDC,IAAbX,EAAEU,SA3BYA,EA6BDV,EAAEU,SA5BF,KAAOA,EAAS,KAAkB,MAAXA,EA4BZtB,EAASwB,KAAKZ,EAAG,KAAMA,GAC9CZ,EAASwB,KAAKZ,EAAGA,EAAG,KAC7B,CA2CA,MAvCI,WAAYA,EACZA,EAAEa,OAASJ,EAEXT,EAAEc,mBAAqB,WACE,IAAjBd,EAAEe,YACFN,GAER,EAKJT,EAAEgB,QAAU,SAAeC,GAEvB7B,EAASwB,KAAKR,KAAMa,IAAO,EAAM,MACjC7B,EAAW,WAAa,CAC5B,EAGAY,EAAEkB,WAAa,WAAa,EAE5BlB,EAAEmB,UAAY,SAASF,GACnB7B,EAASwB,KAAKR,KAAMa,EAAK,MACzB7B,EAAW,WAAa,CAC5B,EAEAY,EAAEoB,QAAU,SAASH,GACjB7B,EAASwB,KAAKR,KAAMa,EAAK,MACzB7B,EAAW,WAAa,CAC5B,EAIAY,EAAEqB,KAAK,MAAOlC,GAAK,GAGnBa,EAAEsB,KAAK,MACPhC,GAAO,EAEAU,CACX,C,uBC/EA,IAAIuB,EAAW,CAAC,EAEhB,SAASC,EAAOC,EAAYC,GACxBD,EAAaE,KAAKC,MAAMH,EAAaC,IACrCD,IAAe,GACE,IACbA,GAAcA,GAGlB,IADA,IAAII,EAAS,GACNJ,GAAc,IACjBI,GAAUC,OAAOC,aAA4C,IAA9B,GAAqB,GAAbN,IACvCA,IAAe,EAGnB,OADAI,EAAUC,OAAOC,aAAaN,EAAa,GAE/C,CAoFA,SAASO,EAAQC,GAEb,IADA,IAAID,EAAU,GACLE,EAAI,EAAGA,EAAID,EAAOE,OAAQD,IAC/BF,EAAQI,KAAKH,EAAOC,GAAGG,QAAQC,WAEnC,OAAON,CACX,CA7EAT,EAASgB,OAAS,SAASC,EAAKC,GAe5B,IAdA,IAOIC,EAPAC,EAAQ,EACRC,EAAM,EACNC,EAAM,EACNC,EAAc,GACdC,EAAQ,EACRC,EAAS,EACTC,EAAO,KAGPvB,EAASC,KAAKuB,IAAI,GAAIT,GAAa,GAKhCE,EAAQH,EAAIL,QAAQ,CAGvBc,EAAO,KACPF,EAAQ,EACRC,EAAS,EAET,GAEIA,IAAkB,IADlBC,EAAOT,EAAIW,WAAWR,KAAW,MACNI,EAC3BA,GAAS,QACJE,GAAQ,IAEjBP,EAA6B,EAATM,IAAgBA,GAAU,GAAMA,GAAU,EAE9DD,EAAQC,EAAS,EAEjB,GAEIA,IAAkB,IADlBC,EAAOT,EAAIW,WAAWR,KAAW,MACNI,EAC3BA,GAAS,QACJE,GAAQ,IAIjBL,GAAOF,EACPG,GAH8B,EAATG,IAAgBA,GAAU,GAAMA,GAAU,EAK/DF,EAAYV,KAAK,CAACQ,EAAMlB,EAAQmB,EAAMnB,GAC1C,CAEA,OAAOoB,CACX,EASAvB,EAASC,OAAS,SAASsB,EAAaL,GACpC,IAAKK,EAAYX,OAAU,MAAO,GAKlC,IAHA,IAAIT,EAASC,KAAKuB,IAAI,GAAIT,GAAa,GACnCZ,EAASL,EAAOsB,EAAY,GAAG,GAAIpB,GAAUF,EAAOsB,EAAY,GAAG,GAAIpB,GAElEQ,EAAI,EAAGA,EAAIY,EAAYX,OAAQD,IAAK,CACzC,IAAIkB,EAAIN,EAAYZ,GAAImB,EAAIP,EAAYZ,EAAI,GAC5CL,GAAUL,EAAO4B,EAAE,GAAKC,EAAE,GAAI3B,GAC9BG,GAAUL,EAAO4B,EAAE,GAAKC,EAAE,GAAI3B,EAClC,CAEA,OAAOG,CACX,EAiBAN,EAAS+B,YAAc,SAASC,EAASd,GAIrC,GAHIc,GAA4B,YAAjBA,EAAQC,OACnBD,EAAUA,EAAQE,WAEjBF,GAA4B,eAAjBA,EAAQC,KACpB,MAAM,IAAI/D,MAAM,sCAEpB,OAAO8B,EAASC,OAAOQ,EAAQuB,EAAQT,aAAcL,EACzD,EASAlB,EAASmC,UAAY,SAASlB,EAAKC,GAE/B,MAAO,CACHe,KAAM,aACNV,YAAad,EAHJT,EAASgB,OAAOC,EAAKC,IAKtC,EAEkCxD,EAAOC,UACrCD,EAAOC,QAAUqC,E,SCtJrBtC,EAAOC,QAAUyE,EACjB1E,EAAOC,QAAQyE,MAAQA,EACvB1E,EAAOC,QAAQ0E,UAiOf,SAASA,EAAWC,GAKlB,SAASC,EAASC,GAChB,OAAOA,EAAEC,KAAK,IAChB,CAEA,SAASC,EAASC,GAChB,OAAOA,EAAEC,IAAIL,GAASE,KAAK,KAC7B,CAEA,SAASI,EAAUF,GACjB,OAAOA,EAAEC,IAAIF,GAASE,IAAIE,GAAYL,KAAK,KAC7C,CAMA,SAASK,EAAYC,GAAK,MAAO,IAAMA,EAAI,GAAK,CAEhD,OAtBgB,YAAZT,EAAGL,OACLK,EAAKA,EAAGJ,UAqBFI,EAAGL,MACT,IAAK,QACH,MAAO,UAAYM,EAAQD,EAAGf,aAAe,IAC/C,IAAK,aACH,MAAO,eAAiBmB,EAAQJ,EAAGf,aAAe,IACpD,IAAK,UACH,MAAO,YAAcsB,EAASP,EAAGf,aAAe,IAClD,IAAK,aACH,MAAO,eAAiBmB,EAAQJ,EAAGf,aAAe,IACpD,IAAK,eACH,MAAO,iBAAiCe,EAAGf,YAfpCqB,IAAIC,GAAUD,IAAIE,GAAYL,KAAK,MAegB,IAC5D,IAAK,kBACH,MAAO,oBAAsBI,EAASP,EAAGf,aAAe,IAC1D,IAAK,qBACH,MAAO,uBAAyBe,EAAGU,WAAWJ,IAAIP,GAAWI,KAAK,MAAQ,IAC5E,QACE,MAAM,IAAIvE,MAAM,0EAEtB,EAxQA,IAAI+E,EAAe,iDAEfC,EAAS,IAAIC,OAAO,IAAMF,EAAaG,OAAS,OAASH,EAAaG,OAAS,SAQnF,SAAShB,EAAOiB,GACd,IAecC,EAfVC,EAAQF,EAAMG,MAAM,KACpBC,EAAIF,EAAMG,MACVC,GAAQJ,EAAM/B,SAAW,IAAIgC,MAAM,KAAKE,MAExC/C,EAAI,EAER,SAASiD,EAAGC,GACV,IAAIzF,EAAQqF,EAAEK,UAAUnD,GAAGvC,MAAMyF,GACjC,OAAKzF,GAEHuC,GAAKvC,EAAM,GAAGwC,OACPxC,EAAM,IAHI,IAKrB,CAeA,SAAS2F,IAAWH,EAAE,OAAS,CAE/B,SAASI,IACPD,IAOA,IANA,IAIIE,EAJAC,EAAQ,EACRC,EAAQ,GACRC,EAAQ,CAACD,GACTE,EAAUF,EAGPF,EACAL,EAAE,UACAA,EAAE,UACAA,EAAE,UACAA,EAAEV,IAAS,CACtB,GAAa,MAATe,EACFG,EAAMvD,KAAKwD,GACXA,EAAU,GACVD,EAAMA,EAAMxD,OAAS,GAAGC,KAAKwD,GAC7BH,SACK,GAAa,MAATD,EAAc,CAEvB,GAAuB,IAAnBI,EAAQzD,OAAc,OAAO,KAIjC,KAFAyD,EAAUD,EAAMV,OAEF,OAAO,KAErB,GAAc,KADdQ,EACiB,KACnB,MAAO,GAAa,MAATD,EACTI,EAAU,GACVD,EAAMA,EAAMxD,OAAS,GAAGC,KAAKwD,OACxB,IAAKJ,EAAKT,MAAM,OAAOc,KAAKC,OAGjC,OAAO,KAFPC,MAAMC,UAAU5D,KAAKjC,MAAMyF,EAASJ,EAAKT,MAAM,OAAOZ,IAAI8B,YAG5D,CACAX,GACF,CAEA,OAAc,IAAVG,EAAoB,KAEjBC,CACT,CAEA,SAASzD,IAIP,IAHA,IACIiE,EACAC,EAFAC,EAAO,GAGJD,EACAhB,EAAEV,IACAU,EAAE,UACE,MAAPgB,GACFC,EAAKhE,KAAK8D,GACVA,EAAO,IACGC,EAAGpB,MAAM,OAAOc,KAAKC,SAC1BI,IAAMA,EAAO,IAClBH,MAAMC,UAAU5D,KAAKjC,MAAM+F,EAAMC,EAAGpB,MAAM,OAAOZ,IAAI8B,cAEvDX,IAGF,OAAIY,GAAME,EAAKhE,KAAK8D,GAGbE,EAAKjE,OAASiE,EAAO,MAFhB,IAGd,CAgHA,OA/LcvB,EAqLd,SAASwB,IACP,OArGF,WACE,IAAKlB,EAAE,aAAc,OAAO,KAE5B,GADAG,KACKH,EAAE,SAAU,OAAO,KACxB,IAAIpB,EAAI9B,IACR,OAAK8B,GACLuB,IACKH,EAAE,SACA,CACL3B,KAAM,QACNV,YAAaiB,EAAE,IAHO,MAFT,IAOjB,CAyFSuC,IA1DT,WACE,IAAKnB,EAAE,kBAAmB,OAAO,KAEjC,GADAG,KACKH,EAAE,SAAU,OAAO,KACxB,IAAIpB,EAAI9B,IACR,OAAK8B,GACAoB,EAAE,SACA,CACL3B,KAAM,aACNV,YAAaiB,GAJA,IAMjB,CAgDIwC,IA9CJ,WACE,IAAKpB,EAAE,eAAgB,OAAO,KAC9BG,IACA,IAAIvB,EAAIwB,IACR,OAAKxB,EACE,CACLP,KAAM,UACNV,YAAaiB,GAHA,IAKjB,CAsCIyC,IAzFJ,WACE,IAAKrB,EAAE,kBAAmB,OAAO,KACjCG,IACA,IAAImB,EAAkBzB,EACnBK,UAAUL,EAAE0B,QAAQ,KAAO,EAAG1B,EAAE7C,OAAS,GACzCwE,QAAQ,MAAO,IACfA,QAAQ,MAAO,IAClB3B,EAAI,eAAiByB,EAAkB,IACvC,IAAI1C,EAAIwB,IACR,OAAKxB,GACLuB,IACO,CACL9B,KAAM,aACNV,YAAaiB,IAJA,IAMjB,CA2EI6C,IAzEJ,WACE,IAAKzB,EAAE,uBAAwB,OAAO,KACtCG,IACA,IAAIvB,EAAIwB,IACR,OAAKxB,GACLuB,IACO,CACL9B,KAAM,kBACNV,YAAaiB,IAJA,IAMjB,CAgEI8C,IAtCJ,WACE,IAAK1B,EAAE,oBAAqB,OAAO,KACnCG,IACA,IAAIvB,EAAIwB,IACR,OAAKxB,EACE,CACLP,KAAM,eACNV,YAAaiB,GAHA,IAKjB,CA8BI+C,IA5BJ,WACE,IACIrD,EADAc,EAAa,GAGjB,IAAKY,EAAE,0BAA2B,OAAO,KAGzC,GAFAG,KAEKH,EAAE,SAAU,OAAO,KACxB,KAAO1B,EAAW4C,KAChB9B,EAAWnC,KAAKqB,GAChB6B,IACAH,EAAE,SACFG,IAEF,OAAKH,EAAE,SAEA,CACL3B,KAAM,qBACNe,WAAYA,GAJU,IAM1B,CASIwC,EACJ,CAEWV,KA9LEnB,EAAKvF,MAAM,SACpBkF,EAAImC,IAAM,CACRxD,KAAM,OACNyD,WAAY,CACVC,KAAM,yBAA2BhC,KAKhCL,CAsLX,C,qBC/NA5F,EAAOC,QAAUiI,W,uBCAjBlI,EAAOC,QAAUwE,S,uBCAjBzE,EAAOC,QAAUkI,Q,GCCbC,EAA2B,CAAC,GAGhC,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqB5G,IAAjB6G,EACH,OAAOA,EAAatI,QAGrB,IAAID,EAASoI,EAAyBE,GAAY,CAGjDrI,QAAS,CAAC,GAOX,OAHAuI,EAAoBF,GAAUtI,EAAQA,EAAOC,QAASoI,GAG/CrI,EAAOC,OACf,CCnB0BoI,CAAoB,I","sources":["webpack://leaflet.extras/./node_modules/@mapbox/leaflet-omnivore/index.js","webpack://leaflet.extras/./node_modules/corslite/corslite.js","webpack://leaflet.extras/./node_modules/polyline/src/polyline.js","webpack://leaflet.extras/./node_modules/wellknown/index.js","webpack://leaflet.extras/external var \"csv2geojson\"","webpack://leaflet.extras/external var \"toGeoJSON\"","webpack://leaflet.extras/external var \"topojson\"","webpack://leaflet.extras/webpack/bootstrap","webpack://leaflet.extras/webpack/startup"],"sourcesContent":["var xhr = require('corslite'),\n    csv2geojson = require('csv2geojson'),\n    wellknown = require('wellknown'),\n    polyline = require('polyline'),\n    topojson = require('topojson'),\n    toGeoJSON = require('togeojson');\n\nmodule.exports.polyline = polylineLoad;\nmodule.exports.polyline.parse = polylineParse;\n\nmodule.exports.geojson = geojsonLoad;\n\nmodule.exports.topojson = topojsonLoad;\nmodule.exports.topojson.parse = topojsonParse;\n\nmodule.exports.csv = csvLoad;\nmodule.exports.csv.parse = csvParse;\n\nmodule.exports.gpx = gpxLoad;\nmodule.exports.gpx.parse = gpxParse;\n\nmodule.exports.kml = kmlLoad;\nmodule.exports.kml.parse = kmlParse;\n\nmodule.exports.wkt = wktLoad;\nmodule.exports.wkt.parse = wktParse;\n\nfunction addData(l, d) {\n    if ('setGeoJSON' in l) {\n        l.setGeoJSON(d);\n    } else if ('addData' in l) {\n        l.addData(d);\n    }\n}\n\n/**\n * Load a [GeoJSON](http://geojson.org/) document into a layer and return the layer.\n *\n * @param {string} url\n * @param {object} options\n * @param {object} customLayer\n * @returns {object}\n */\nfunction geojsonLoad(url, options, customLayer) {\n    var layer = customLayer || L.geoJson();\n    xhr(url, function(err, response) {\n        if (err) return layer.fire('error', { error: err });\n        addData(layer, JSON.parse(response.responseText));\n        layer.fire('ready');\n    });\n    return layer;\n}\n\n/**\n * Load a [TopoJSON](https://github.com/mbostock/topojson) document into a layer and return the layer.\n *\n * @param {string} url\n * @param {object} options\n * @param {object} customLayer\n * @returns {object}\n */\nfunction topojsonLoad(url, options, customLayer) {\n    var layer = customLayer || L.geoJson();\n    xhr(url, onload);\n    function onload(err, response) {\n        if (err) return layer.fire('error', { error: err });\n        topojsonParse(response.responseText, options, layer);\n        layer.fire('ready');\n    }\n    return layer;\n}\n\n/**\n * Load a CSV document into a layer and return the layer.\n *\n * @param {string} url\n * @param {object} options\n * @param {object} customLayer\n * @returns {object}\n */\nfunction csvLoad(url, options, customLayer) {\n    var layer = customLayer || L.geoJson();\n    xhr(url, onload);\n    function onload(err, response) {\n        var error;\n        if (err) return layer.fire('error', { error: err });\n        function avoidReady() {\n            error = true;\n        }\n        layer.on('error', avoidReady);\n        csvParse(response.responseText, options, layer);\n        layer.off('error', avoidReady);\n        if (!error) layer.fire('ready');\n    }\n    return layer;\n}\n\n/**\n * Load a GPX document into a layer and return the layer.\n *\n * @param {string} url\n * @param {object} options\n * @param {object} customLayer\n * @returns {object}\n */\nfunction gpxLoad(url, options, customLayer) {\n    var layer = customLayer || L.geoJson();\n    xhr(url, onload);\n    function onload(err, response) {\n        var error;\n        if (err) return layer.fire('error', { error: err });\n        function avoidReady() {\n            error = true;\n        }\n        layer.on('error', avoidReady);\n        gpxParse(response.responseXML || response.responseText, options, layer);\n        layer.off('error', avoidReady);\n        if (!error) layer.fire('ready');\n    }\n    return layer;\n}\n\n/**\n * Load a [KML](https://developers.google.com/kml/documentation/) document into a layer and return the layer.\n *\n * @param {string} url\n * @param {object} options\n * @param {object} customLayer\n * @returns {object}\n */\nfunction kmlLoad(url, options, customLayer) {\n    var layer = customLayer || L.geoJson();\n    xhr(url, onload);\n    function onload(err, response) {\n        var error;\n        if (err) return layer.fire('error', { error: err });\n        function avoidReady() {\n            error = true;\n        }\n        layer.on('error', avoidReady);\n        kmlParse(response.responseXML || response.responseText, options, layer);\n        layer.off('error', avoidReady);\n        if (!error) layer.fire('ready');\n    }\n    return layer;\n}\n\n/**\n * Load a WKT (Well Known Text) string into a layer and return the layer\n *\n * @param {string} url\n * @param {object} options\n * @param {object} customLayer\n * @returns {object}\n */\nfunction wktLoad(url, options, customLayer) {\n    var layer = customLayer || L.geoJson();\n    xhr(url, onload);\n    function onload(err, response) {\n        if (err) return layer.fire('error', { error: err });\n        wktParse(response.responseText, options, layer);\n        layer.fire('ready');\n    }\n    return layer;\n}\n\n/**\n * Load a polyline string into a layer and return the layer\n *\n * @param {string} url\n * @param {object} options\n * @param {object} customLayer\n * @returns {object}\n */\nfunction polylineLoad(url, options, customLayer) {\n    var layer = customLayer || L.geoJson();\n    xhr(url, onload);\n    function onload(err, response) {\n        if (err) return layer.fire('error', { error: err });\n        polylineParse(response.responseText, options, layer);\n        layer.fire('ready');\n    }\n    return layer;\n}\n\nfunction topojsonParse(data, options, layer) {\n    var o = typeof data === 'string' ?\n        JSON.parse(data) : data;\n    layer = layer || L.geoJson();\n    for (var i in o.objects) {\n        var ft = topojson.feature(o, o.objects[i]);\n        if (ft.features) addData(layer, ft.features);\n        else addData(layer, ft);\n    }\n    return layer;\n}\n\nfunction csvParse(csv, options, layer) {\n    layer = layer || L.geoJson();\n    options = options || {};\n    csv2geojson.csv2geojson(csv, options, onparse);\n    function onparse(err, geojson) {\n        if (err) return layer.fire('error', { error: err });\n        addData(layer, geojson);\n    }\n    return layer;\n}\n\nfunction gpxParse(gpx, options, layer) {\n    var xml = parseXML(gpx);\n    if (!xml) return layer.fire('error', {\n        error: 'Could not parse GPX'\n    });\n    layer = layer || L.geoJson();\n    var geojson = toGeoJSON.gpx(xml);\n    addData(layer, geojson);\n    return layer;\n}\n\n\nfunction kmlParse(gpx, options, layer) {\n    var xml = parseXML(gpx);\n    if (!xml) return layer.fire('error', {\n        error: 'Could not parse KML'\n    });\n    layer = layer || L.geoJson();\n    var geojson = toGeoJSON.kml(xml);\n    addData(layer, geojson);\n    return layer;\n}\n\nfunction polylineParse(txt, options, layer) {\n    layer = layer || L.geoJson();\n    options = options || {};\n    var coords = polyline.decode(txt, options.precision);\n    var geojson = { type: 'LineString', coordinates: [] };\n    for (var i = 0; i < coords.length; i++) {\n        // polyline returns coords in lat, lng order, so flip for geojson\n        geojson.coordinates[i] = [coords[i][1], coords[i][0]];\n    }\n    addData(layer, geojson);\n    return layer;\n}\n\nfunction wktParse(wkt, options, layer) {\n    layer = layer || L.geoJson();\n    var geojson = wellknown(wkt);\n    addData(layer, geojson);\n    return layer;\n}\n\nfunction parseXML(str) {\n    if (typeof str === 'string') {\n        return (new DOMParser()).parseFromString(str, 'text/xml');\n    } else {\n        return str;\n    }\n}\n","function corslite(url, callback, cors) {\n    var sent = false;\n\n    if (typeof window.XMLHttpRequest === 'undefined') {\n        return callback(Error('Browser not supported'));\n    }\n\n    if (typeof cors === 'undefined') {\n        var m = url.match(/^\\s*https?:\\/\\/[^\\/]*/);\n        cors = m && (m[0] !== location.protocol + '//' + location.hostname +\n                (location.port ? ':' + location.port : ''));\n    }\n\n    var x = new window.XMLHttpRequest();\n\n    function isSuccessful(status) {\n        return status >= 200 && status < 300 || status === 304;\n    }\n\n    if (cors && !('withCredentials' in x)) {\n        // IE8-9\n        x = new window.XDomainRequest();\n\n        // Ensure callback is never called synchronously, i.e., before\n        // x.send() returns (this has been observed in the wild).\n        // See https://github.com/mapbox/mapbox.js/issues/472\n        var original = callback;\n        callback = function() {\n            if (sent) {\n                original.apply(this, arguments);\n            } else {\n                var that = this, args = arguments;\n                setTimeout(function() {\n                    original.apply(that, args);\n                }, 0);\n            }\n        }\n    }\n\n    function loaded() {\n        if (\n            // XDomainRequest\n            x.status === undefined ||\n            // modern browsers\n            isSuccessful(x.status)) callback.call(x, null, x);\n        else callback.call(x, x, null);\n    }\n\n    // Both `onreadystatechange` and `onload` can fire. `onreadystatechange`\n    // has [been supported for longer](http://stackoverflow.com/a/9181508/229001).\n    if ('onload' in x) {\n        x.onload = loaded;\n    } else {\n        x.onreadystatechange = function readystate() {\n            if (x.readyState === 4) {\n                loaded();\n            }\n        };\n    }\n\n    // Call the callback with the XMLHttpRequest object as an error and prevent\n    // it from ever being called again by reassigning it to `noop`\n    x.onerror = function error(evt) {\n        // XDomainRequest provides no evt parameter\n        callback.call(this, evt || true, null);\n        callback = function() { };\n    };\n\n    // IE9 must have onprogress be set to a unique function.\n    x.onprogress = function() { };\n\n    x.ontimeout = function(evt) {\n        callback.call(this, evt, null);\n        callback = function() { };\n    };\n\n    x.onabort = function(evt) {\n        callback.call(this, evt, null);\n        callback = function() { };\n    };\n\n    // GET is the only supported HTTP Verb by XDomainRequest and is the\n    // only one supported here.\n    x.open('GET', url, true);\n\n    // Send the request. Sending data is not supported.\n    x.send(null);\n    sent = true;\n\n    return x;\n}\n\nif (typeof module !== 'undefined') module.exports = corslite;\n","'use strict';\n\n/**\n * Based off of [the offical Google document](https://developers.google.com/maps/documentation/utilities/polylinealgorithm)\n *\n * Some parts from [this implementation](http://facstaff.unca.edu/mcmcclur/GoogleMaps/EncodePolyline/PolylineEncoder.js)\n * by [Mark McClure](http://facstaff.unca.edu/mcmcclur/)\n *\n * @module polyline\n */\n\nvar polyline = {};\n\nfunction encode(coordinate, factor) {\n    coordinate = Math.round(coordinate * factor);\n    coordinate <<= 1;\n    if (coordinate < 0) {\n        coordinate = ~coordinate;\n    }\n    var output = '';\n    while (coordinate >= 0x20) {\n        output += String.fromCharCode((0x20 | (coordinate & 0x1f)) + 63);\n        coordinate >>= 5;\n    }\n    output += String.fromCharCode(coordinate + 63);\n    return output;\n}\n\n/**\n * Decodes to a [latitude, longitude] coordinates array.\n *\n * This is adapted from the implementation in Project-OSRM.\n *\n * @param {String} str\n * @param {Number} precision\n * @returns {Array}\n *\n * @see https://github.com/Project-OSRM/osrm-frontend/blob/master/WebContent/routing/OSRM.RoutingGeometry.js\n */\npolyline.decode = function(str, precision) {\n    var index = 0,\n        lat = 0,\n        lng = 0,\n        coordinates = [],\n        shift = 0,\n        result = 0,\n        byte = null,\n        latitude_change,\n        longitude_change,\n        factor = Math.pow(10, precision || 5);\n\n    // Coordinates have variable length when encoded, so just keep\n    // track of whether we've hit the end of the string. In each\n    // loop iteration, a single coordinate is decoded.\n    while (index < str.length) {\n\n        // Reset shift, result, and byte\n        byte = null;\n        shift = 0;\n        result = 0;\n\n        do {\n            byte = str.charCodeAt(index++) - 63;\n            result |= (byte & 0x1f) << shift;\n            shift += 5;\n        } while (byte >= 0x20);\n\n        latitude_change = ((result & 1) ? ~(result >> 1) : (result >> 1));\n\n        shift = result = 0;\n\n        do {\n            byte = str.charCodeAt(index++) - 63;\n            result |= (byte & 0x1f) << shift;\n            shift += 5;\n        } while (byte >= 0x20);\n\n        longitude_change = ((result & 1) ? ~(result >> 1) : (result >> 1));\n\n        lat += latitude_change;\n        lng += longitude_change;\n\n        coordinates.push([lat / factor, lng / factor]);\n    }\n\n    return coordinates;\n};\n\n/**\n * Encodes the given [latitude, longitude] coordinates array.\n *\n * @param {Array.<Array.<Number>>} coordinates\n * @param {Number} precision\n * @returns {String}\n */\npolyline.encode = function(coordinates, precision) {\n    if (!coordinates.length) { return ''; }\n\n    var factor = Math.pow(10, precision || 5),\n        output = encode(coordinates[0][0], factor) + encode(coordinates[0][1], factor);\n\n    for (var i = 1; i < coordinates.length; i++) {\n        var a = coordinates[i], b = coordinates[i - 1];\n        output += encode(a[0] - b[0], factor);\n        output += encode(a[1] - b[1], factor);\n    }\n\n    return output;\n};\n\nfunction flipped(coords) {\n    var flipped = [];\n    for (var i = 0; i < coords.length; i++) {\n        flipped.push(coords[i].slice().reverse());\n    }\n    return flipped;\n}\n\n/**\n * Encodes a GeoJSON LineString feature/geometry.\n *\n * @param {Object} geojson\n * @param {Number} precision\n * @returns {String}\n */\npolyline.fromGeoJSON = function(geojson, precision) {\n    if (geojson && geojson.type === 'Feature') {\n        geojson = geojson.geometry;\n    }\n    if (!geojson || geojson.type !== 'LineString') {\n        throw new Error('Input must be a GeoJSON LineString');\n    }\n    return polyline.encode(flipped(geojson.coordinates), precision);\n};\n\n/**\n * Decodes to a GeoJSON LineString geometry.\n *\n * @param {String} str\n * @param {Number} precision\n * @returns {Object}\n */\npolyline.toGeoJSON = function(str, precision) {\n    var coords = polyline.decode(str, precision);\n    return {\n        type: 'LineString',\n        coordinates: flipped(coords)\n    };\n};\n\nif (typeof module === 'object' && module.exports) {\n    module.exports = polyline;\n}\n","/*eslint-disable no-cond-assign */\nmodule.exports = parse;\nmodule.exports.parse = parse;\nmodule.exports.stringify = stringify;\n\nvar numberRegexp = /[-+]?([0-9]*\\.[0-9]+|[0-9]+)([eE][-+]?[0-9]+)?/;\n// Matches sequences like '100 100' or '100 100 100'.\nvar tuples = new RegExp('^' + numberRegexp.source + '(\\\\s' + numberRegexp.source + '){1,}');\n\n/*\n * Parse WKT and return GeoJSON.\n *\n * @param {string} _ A WKT geometry\n * @return {?Object} A GeoJSON geometry object\n */\nfunction parse (input) {\n  var parts = input.split(';');\n  var _ = parts.pop();\n  var srid = (parts.shift() || '').split('=').pop();\n\n  var i = 0;\n\n  function $ (re) {\n    var match = _.substring(i).match(re);\n    if (!match) return null;\n    else {\n      i += match[0].length;\n      return match[0];\n    }\n  }\n\n  function crs (obj) {\n    if (obj && srid.match(/\\d+/)) {\n      obj.crs = {\n        type: 'name',\n        properties: {\n          name: 'urn:ogc:def:crs:EPSG::' + srid\n        }\n      };\n    }\n\n    return obj;\n  }\n\n  function white () { $(/^\\s*/); }\n\n  function multicoords () {\n    white();\n    var depth = 0;\n    var rings = [];\n    var stack = [rings];\n    var pointer = rings;\n    var elem;\n\n    while (elem =\n           $(/^(\\()/) ||\n             $(/^(\\))/) ||\n               $(/^(\\,)/) ||\n                 $(tuples)) {\n      if (elem === '(') {\n        stack.push(pointer);\n        pointer = [];\n        stack[stack.length - 1].push(pointer);\n        depth++;\n      } else if (elem === ')') {\n        // For the case: Polygon(), ...\n        if (pointer.length === 0) return null;\n\n        pointer = stack.pop();\n        // the stack was empty, input was malformed\n        if (!pointer) return null;\n        depth--;\n        if (depth === 0) break;\n      } else if (elem === ',') {\n        pointer = [];\n        stack[stack.length - 1].push(pointer);\n      } else if (!elem.split(/\\s/g).some(isNaN)) {\n        Array.prototype.push.apply(pointer, elem.split(/\\s/g).map(parseFloat));\n      } else {\n        return null;\n      }\n      white();\n    }\n\n    if (depth !== 0) return null;\n\n    return rings;\n  }\n\n  function coords () {\n    var list = [];\n    var item;\n    var pt;\n    while (pt =\n           $(tuples) ||\n             $(/^(\\,)/)) {\n      if (pt === ',') {\n        list.push(item);\n        item = [];\n      } else if (!pt.split(/\\s/g).some(isNaN)) {\n        if (!item) item = [];\n        Array.prototype.push.apply(item, pt.split(/\\s/g).map(parseFloat));\n      }\n      white();\n    }\n\n    if (item) list.push(item);\n    else return null;\n\n    return list.length ? list : null;\n  }\n\n  function point () {\n    if (!$(/^(point)/i)) return null;\n    white();\n    if (!$(/^(\\()/)) return null;\n    var c = coords();\n    if (!c) return null;\n    white();\n    if (!$(/^(\\))/)) return null;\n    return {\n      type: 'Point',\n      coordinates: c[0]\n    };\n  }\n\n  function multipoint () {\n    if (!$(/^(multipoint)/i)) return null;\n    white();\n    var newCoordsFormat = _\n      .substring(_.indexOf('(') + 1, _.length - 1)\n      .replace(/\\(/g, '')\n      .replace(/\\)/g, '');\n    _ = 'MULTIPOINT (' + newCoordsFormat + ')';\n    var c = multicoords();\n    if (!c) return null;\n    white();\n    return {\n      type: 'MultiPoint',\n      coordinates: c\n    };\n  }\n\n  function multilinestring () {\n    if (!$(/^(multilinestring)/i)) return null;\n    white();\n    var c = multicoords();\n    if (!c) return null;\n    white();\n    return {\n      type: 'MultiLineString',\n      coordinates: c\n    };\n  }\n\n  function linestring () {\n    if (!$(/^(linestring)/i)) return null;\n    white();\n    if (!$(/^(\\()/)) return null;\n    var c = coords();\n    if (!c) return null;\n    if (!$(/^(\\))/)) return null;\n    return {\n      type: 'LineString',\n      coordinates: c\n    };\n  }\n\n  function polygon () {\n    if (!$(/^(polygon)/i)) return null;\n    white();\n    var c = multicoords();\n    if (!c) return null;\n    return {\n      type: 'Polygon',\n      coordinates: c\n    };\n  }\n\n  function multipolygon () {\n    if (!$(/^(multipolygon)/i)) return null;\n    white();\n    var c = multicoords();\n    if (!c) return null;\n    return {\n      type: 'MultiPolygon',\n      coordinates: c\n    };\n  }\n\n  function geometrycollection () {\n    var geometries = [];\n    var geometry;\n\n    if (!$(/^(geometrycollection)/i)) return null;\n    white();\n\n    if (!$(/^(\\()/)) return null;\n    while (geometry = root()) {\n      geometries.push(geometry);\n      white();\n      $(/^(\\,)/);\n      white();\n    }\n    if (!$(/^(\\))/)) return null;\n\n    return {\n      type: 'GeometryCollection',\n      geometries: geometries\n    };\n  }\n\n  function root () {\n    return point() ||\n      linestring() ||\n      polygon() ||\n      multipoint() ||\n      multilinestring() ||\n      multipolygon() ||\n      geometrycollection();\n  }\n\n  return crs(root());\n}\n\n/**\n * Stringifies a GeoJSON object into WKT\n */\nfunction stringify (gj) {\n  if (gj.type === 'Feature') {\n    gj = gj.geometry;\n  }\n\n  function pairWKT (c) {\n    return c.join(' ');\n  }\n\n  function ringWKT (r) {\n    return r.map(pairWKT).join(', ');\n  }\n\n  function ringsWKT (r) {\n    return r.map(ringWKT).map(wrapParens).join(', ');\n  }\n\n  function multiRingsWKT (r) {\n    return r.map(ringsWKT).map(wrapParens).join(', ');\n  }\n\n  function wrapParens (s) { return '(' + s + ')'; }\n\n  switch (gj.type) {\n    case 'Point':\n      return 'POINT (' + pairWKT(gj.coordinates) + ')';\n    case 'LineString':\n      return 'LINESTRING (' + ringWKT(gj.coordinates) + ')';\n    case 'Polygon':\n      return 'POLYGON (' + ringsWKT(gj.coordinates) + ')';\n    case 'MultiPoint':\n      return 'MULTIPOINT (' + ringWKT(gj.coordinates) + ')';\n    case 'MultiPolygon':\n      return 'MULTIPOLYGON (' + multiRingsWKT(gj.coordinates) + ')';\n    case 'MultiLineString':\n      return 'MULTILINESTRING (' + ringsWKT(gj.coordinates) + ')';\n    case 'GeometryCollection':\n      return 'GEOMETRYCOLLECTION (' + gj.geometries.map(stringify).join(', ') + ')';\n    default:\n      throw new Error('stringify requires a valid GeoJSON Feature or geometry object as input');\n  }\n}\n","module.exports = csv2geojson;","module.exports = toGeoJSON;","module.exports = topojson;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module used 'module' so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(390);\n"],"names":["module","exports","url","callback","cors","sent","window","XMLHttpRequest","Error","m","match","location","protocol","hostname","port","x","XDomainRequest","original","apply","this","arguments","that","args","setTimeout","loaded","status","undefined","call","onload","onreadystatechange","readyState","onerror","evt","onprogress","ontimeout","onabort","open","send","polyline","encode","coordinate","factor","Math","round","output","String","fromCharCode","flipped","coords","i","length","push","slice","reverse","decode","str","precision","latitude_change","index","lat","lng","coordinates","shift","result","byte","pow","charCodeAt","a","b","fromGeoJSON","geojson","type","geometry","toGeoJSON","parse","stringify","gj","pairWKT","c","join","ringWKT","r","map","ringsWKT","wrapParens","s","geometries","numberRegexp","tuples","RegExp","source","input","obj","parts","split","_","pop","srid","$","re","substring","white","multicoords","elem","depth","rings","stack","pointer","some","isNaN","Array","prototype","parseFloat","item","pt","list","root","point","linestring","polygon","newCoordsFormat","indexOf","replace","multipoint","multilinestring","multipolygon","geometrycollection","crs","properties","name","csv2geojson","topojson","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__"],"sourceRoot":""}