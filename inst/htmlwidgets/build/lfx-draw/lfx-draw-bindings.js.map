{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./inst/htmlwidgets/bindings/lfx-draw-bindings.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","LeafletWidget","methods","addDrawToolbar","targetLayerId","targetGroup","options","mouseHandler","mapId","layerId","group","eventName","extraInfo","e","HTMLWidgets","shinyMode","eventInfo","$","extend","id",".nonce","Math","random","target","getLatLng","latlng","Shiny","onInputChange","editableFeatureGroup","map","this","drawToolbar","removeFrom","drawToobar","layerManager","getLayer","_editableGeoJSONLayerId","getLayerGroup","_editableFeatureGroupName","draw","marker","markerIcon","markerIconFunction","icon","isEmptyObject","edit","editOptions","remove","selectedPathOptions","poly","featureGroup","L","Control","Draw","addTo","on","Event","DRAWSTART","feature_type","layerType","DRAWSTOP","CREATED","singleFeature","getLayers","length","clearLayers","layer","addLayer","featureId","stamp","feature","type","properties","_leaflet_id","getRadius","radius","layerCategory","includes","toGeoJSON","EDITSTART","EDITSTOP","EDITED","layers","eachLayer","DELETESTART","DELETESTOP","DELETED","removeDrawToolbar","clearFeatures","removeLayer","getDrawnItems"],"mappings":"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","file":"lfx-draw-bindings.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/* global LeafletWidget, $, L, Shiny, HTMLWidgets */\n\nLeafletWidget.methods.addDrawToolbar = function(targetLayerId, targetGroup, options) {\n  (function(){\n\n    // Copied from: https://github.com/rstudio/leaflet/blob/8b20549eeca9b7b66019f098a380422377666bc6/javascript/src/methods.js#L17\n    function mouseHandler(mapId, layerId, group, eventName, extraInfo) {\n      return function(e) {\n        if (!HTMLWidgets.shinyMode) return;\n\n        var eventInfo = $.extend(\n          {\n            id: layerId,\n            '.nonce': Math.random()  // force reactivity\n          },\n          group !== null ? {group: group} : null,\n          e.target.getLatLng ? e.target.getLatLng() : e.latlng,\n          extraInfo\n        );\n\n        Shiny.onInputChange(mapId + '_' + eventName, eventInfo);\n      };\n    }\n\n    var map = this;\n\n    if(map.drawToolbar) {\n      map.drawToolbar.removeFrom(map);\n      delete map.drawToobar;\n    }\n\n    // FeatureGroup that will hold our drawn shapes/markers\n    // This can be an existing GeoJSON layer whose features can be edited/deleted or new ones added.\n    // OR an existing FeatureGroup whose features can be edited/deleted or new ones added.\n    // OR a new FeatureGroup to hold drawn shapes.\n    var editableFeatureGroup;\n\n    if(targetLayerId) {\n      // If we're given an existing GeoJSON layer find it and use it\n      editableFeatureGroup = map.layerManager.getLayer('geojson', targetLayerId);\n      if(editableFeatureGroup) {\n        map._editableGeoJSONLayerId = targetLayerId;\n      } else {\n        // throw an error if we can't find the target GeoJSON layer\n        throw 'GeoJSON layer with ID '+targetLayerId+' not Found';\n      }\n    } else {\n      // If we're given an existing FeatureLayer use that.\n      // In this case we don't throw an error if the specified FeatureGroup is not found,\n      // we silently create a new one.\n      if(!targetGroup) {\n        targetGroup = 'editableFeatureGroup';\n      }\n      editableFeatureGroup = map.layerManager.getLayerGroup(targetGroup, true);\n      map._editableFeatureGroupName = targetGroup;\n    }\n\n    // Create appropriate Marker Icon.\n    if(options && options.draw && options.draw.marker) {\n      if(options.draw.marker.markerIcon &&\n        options.draw.marker.markerIconFunction) {\n        options.draw.marker.icon =\n          options.draw.marker.markerIconFunction(\n            options.draw.marker.markerIcon);\n      }\n    }\n\n    // create appropriate options\n    if(!$.isEmptyObject(options.edit)) {\n      var editOptions = {};\n      if(!options.edit.remove) {\n        editOptions.remove = false;\n      }\n      if(!options.edit.edit) {\n        editOptions.edit = false;\n      } else if(!$.isEmptyObject(options.edit.selectedPathOptions)) {\n        editOptions.edit = {};\n        editOptions.edit.selectedPathOptions =\n          options.edit.selectedPathOptions;\n      }\n\n      if(!$.isEmptyObject(options.edit.poly)) {\n        editOptions.poly = options.edit.poly;\n      }\n\n      editOptions.featureGroup = editableFeatureGroup;\n      options.edit = editOptions;\n    }\n\n    map.drawToolbar =  new L.Control.Draw(options);\n    map.drawToolbar.addTo(map);\n\n    // Event Listeners\n    map.on(L.Draw.Event.DRAWSTART, function(e) {\n      if (!HTMLWidgets.shinyMode) return;\n      Shiny.onInputChange(map.id+'_draw_start', {'feature_type': e.layerType});\n    });\n\n    map.on(L.Draw.Event.DRAWSTOP, function(e) {\n      if (!HTMLWidgets.shinyMode) return;\n      Shiny.onInputChange(map.id+'_draw_stop', {'feature_type': e.layerType});\n    });\n\n    map.on(L.Draw.Event.CREATED, function (e) {\n      if (options.draw.singleFeature){\n        if (editableFeatureGroup.getLayers().length > 0) {\n          editableFeatureGroup.clearLayers();\n        }\n      }\n\n      var layer = e.layer;\n      editableFeatureGroup.addLayer(layer);\n\n      // assign a unique key to the newly created feature\n      var featureId = L.stamp(layer);\n      layer.feature = {\n        'type' : 'Feature',\n        'properties' : {\n          '_leaflet_id' : featureId,\n          'feature_type' : e.layerType\n        }\n      };\n\n      // circles are just Points and toGeoJSON won't store radius by default\n      // so we store it inside the properties.\n      if(typeof layer.getRadius === 'function') {\n        layer.feature.properties.radius = layer.getRadius();\n      }\n\n      if (!HTMLWidgets.shinyMode) return;\n\n      // Derive R leaflet layer category (shape, marker) from leaflet layer type\n      var layerCategory = e.layerType;\n\n      if (['rectangle', 'polygon', 'circle'].includes(layerCategory)) {\n        layerCategory = 'shape';\n      } else if (layerCategory === 'circlemarker') {\n        layerCategory = 'marker';\n      }\n\n      // Add R leaflet click, etc, handlers.\n      // Adjusted from: https://github.com/rstudio/leaflet/blob/8b20549eeca9b7b66019f098a380422377666bc6/javascript/src/methods.js#L355\n      layer.on('click', mouseHandler(map.id, featureId, targetGroup, layerCategory + '_click'), map);\n      layer.on('mouseover', mouseHandler(map.id, featureId, targetGroup, layerCategory + '_mouseover'), map);\n      layer.on('mouseout', mouseHandler(map.id, featureId, targetGroup, layerCategory + '_mouseout'), map);\n\n      Shiny.onInputChange(map.id+'_draw_new_feature',\n        layer.toGeoJSON());\n      Shiny.onInputChange(map.id+'_draw_all_features',\n        editableFeatureGroup.toGeoJSON());\n    });\n\n    map.on(L.Draw.Event.EDITSTART, function (e) {\n      if (!HTMLWidgets.shinyMode) return;\n      Shiny.onInputChange(map.id+'_draw_editstart', true);\n    });\n    map.on(L.Draw.Event.EDITSTOP, function (e) {\n      if (!HTMLWidgets.shinyMode) return;\n      Shiny.onInputChange(map.id+'_draw_editstop', true);\n    });\n\n    map.on(L.Draw.Event.EDITED, function (e) {\n      var layers = e.layers;\n      layers.eachLayer(function(layer){\n        var featureId = L.stamp(layer);\n        if(!layer.feature) {\n          layer.feature = {'type' : 'Feature'};\n        }\n        if(!layer.feature.properties) {\n          layer.feature.properties = {};\n        }\n        layer.feature.properties._leaflet_id = featureId;\n        layer.feature.properties.layerId = layer.options.layerId;\n        if(typeof layer.getRadius === 'function') {\n          layer.feature.properties.radius = layer.getRadius();\n        }\n      });\n\n      if (!HTMLWidgets.shinyMode) return;\n\n      Shiny.onInputChange(map.id+'_draw_edited_features',\n        layers.toGeoJSON());\n      Shiny.onInputChange(map.id+'_draw_all_features',\n        editableFeatureGroup.toGeoJSON());\n    });\n\n    map.on(L.Draw.Event.DELETESTART, function (e) {\n      if (!HTMLWidgets.shinyMode) return;\n      Shiny.onInputChange(map.id+'_draw_deletestart', true);\n    });\n\n    map.on(L.Draw.Event.DELETESTOP, function (e) {\n      if (!HTMLWidgets.shinyMode) return;\n      Shiny.onInputChange(map.id+'_draw_deletestop', true);\n    });\n\n    map.on(L.Draw.Event.DELETED, function (e) {\n      var layers = e.layers;\n      layers.eachLayer(function(layer){\n        var featureId = L.stamp(layer);\n        if(!layer.feature) {\n          layer.feature = {'type' : 'Feature'};\n        }\n        if(!layer.feature.properties) {\n          layer.feature.properties = {};\n        }\n        layer.feature.properties._leaflet_id = featureId;\n        layer.feature.properties.layerId = layer.options.layerId;\n        if(typeof layer.getRadius === 'function') {\n          layer.feature.properties.radius = layer.getRadius();\n        }\n      });\n\n      if (!HTMLWidgets.shinyMode) return;\n      Shiny.onInputChange(map.id+'_draw_deleted_features',\n        layers.toGeoJSON());\n      Shiny.onInputChange(map.id+'_draw_all_features',\n        editableFeatureGroup.toGeoJSON());\n    });\n\n  }).call(this);\n\n};\n\nLeafletWidget.methods.removeDrawToolbar = function(clearFeatures) {\n  (function(){\n\n    var map = this;\n\n    if(map.drawToolbar) {\n      map.drawToolbar.removeFrom(map);\n      delete map.drawToolbar;\n    }\n    if(map._editableFeatureGroupName && clearFeatures) {\n      var featureGroup = map.layerManager.getLayerGroup(map._editableFeatureGroupName, false);\n      featureGroup.clearLayers();\n    }\n    map._editableFeatureGroupName = null;\n    if(map._editableGeoJSONLayerId && clearFeatures) {\n      map.layerManager.removeLayer('geojson', map._editableGeoJSONLayerId);\n    }\n    map._editableGeoJSONLayerId = null;\n  }).call(this);\n\n};\n\nLeafletWidget.methods.getDrawnItems = function() {\n  var map = this;\n\n  var featureGroup;\n  if(map._editableGeoJSONLayerId) {\n    featureGroup = map.layerManager.getLayer('geojson', map._editableGeoJSONLayerId);\n  } else if(map._editableFeatureGroupName) {\n    featureGroup = map.layerManager.getLayerGroup(map._editableFeatureGroupName, false);\n  }\n  if(featureGroup) {\n    return featureGroup.toGeoJSON();\n  } else {\n    return null;\n  }\n\n};\n"],"sourceRoot":""}